<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Screen Sharing</title>
</head>

<style>
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }

    video {
        width: 60%;
        border: 1px solid black;
    }

    .explicacion {
        display: flex;
        width: 60%;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
    }

    p,
    li,
    code {
        font-size: 1.5rem;
        line-height: 1.5;
    }
</style>

<body>
    <h1>WebRTC - Compartir y Recibir Pantalla</h1>
    <button id="startSharing">Iniciar Compartici√≥n</button>
    <button id="playVideoButton" style="display: none;">‚ñ∂ Reproducir Video</button>

    <h2>Tu pantalla compartida</h2>
    <video id="localVideo" autoplay playsinline muted></video>

    <h2>Pantalla recibida desde otra pesta√±a</h2>
    <video id="remoteVideo" autoplay playsinline></video>

    <div class="explicacion">
        <h2>üìå ¬øC√≥mo funciona WebRTC con RTCPeerConnection y BroadcastChannel?</h2>
        <p>
            WebRTC permite la comunicaci√≥n de video, audio y datos entre navegadores sin necesidad de un servidor
            intermedio.
            Para lograrlo, utilizamos <code>RTCPeerConnection</code> para establecer una conexi√≥n entre dos pesta√±as y
            <code>BroadcastChannel</code> para intercambiar mensajes de se√±alizaci√≥n entre ellas.
        </p>

        <h3>üì° Proceso de conexi√≥n</h3>
        <ol>
            <li>Una pesta√±a inicia la compartici√≥n de pantalla usando
                <code>navigator.mediaDevices.getDisplayMedia()</code>.
            </li>
            <li>Se crea un objeto <code>RTCPeerConnection</code> para gestionar la conexi√≥n WebRTC.</li>
            <li>El emisor crea una <strong>oferta (offer)</strong> y la env√≠a a trav√©s de <code>BroadcastChannel</code>
                a otras pesta√±as.</li>
            <li>Las pesta√±as receptoras reciben la oferta, crean una <strong>respuesta (answer)</strong> y la env√≠an de
                vuelta.</li>
            <li>Ambos navegadores intercambian <strong>candidatos ICE</strong> para establecer la conexi√≥n directa.</li>
            <li>Una vez establecida la conexi√≥n, la pantalla compartida se muestra en la pesta√±a receptora.</li>
        </ol>

        <h3>üîÑ ¬øQu√© son las ofertas, respuestas y candidatos ICE?</h3>
        <ul>
            <li><strong>Offer (Oferta):</strong> La pesta√±a que inicia la conexi√≥n crea una oferta SDP y la env√≠a al
                receptor.</li>
            <li><strong>Answer (Respuesta):</strong> La pesta√±a receptora responde con una descripci√≥n SDP.</li>
            <li><strong>ICE Candidates:</strong> Son los datos de red que permiten conectar las dos pesta√±as a trav√©s de
                Internet.</li>
        </ul>

        <h3>üí° ¬øPor qu√© usamos BroadcastChannel?</h3>
        <p>
            <code>BroadcastChannel</code> permite la comunicaci√≥n entre pesta√±as abiertas en el mismo navegador.
            En este caso, lo usamos para intercambiar la oferta, la respuesta y los candidatos ICE, lo que permite
            establecer una conexi√≥n WebRTC sin necesidad de un servidor externo.
        </p>

        <h3>üöÄ C√≥digo de Ejemplo</h3>
        <pre>
<code>
// Crear una conexi√≥n WebRTC
const peerConnection = new RTCPeerConnection();

// Crear un canal de comunicaci√≥n entre pesta√±as
const signalingChannel = new BroadcastChannel('webrtc-signaling');

// Enviar oferta cuando se inicia la compartici√≥n
async function startConnection() {
    const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    signalingChannel.postMessage({ type: 'offer', offer });
}

// Manejar mensajes de la otra pesta√±a
signalingChannel.onmessage = async (event) => {
    if (event.data.type === 'offer') {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(event.data.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        signalingChannel.postMessage({ type: 'answer', answer });
    }
};
</code>
</pre>

        <h3>üìö Bibliograf√≠a</h3>
        <p>
            Para m√°s informaci√≥n sobre WebRTC y sus funcionalidades, puedes consultar la documentaci√≥n oficial y
            ejemplos en:
        </p>
        <ul>
            <li><a href="https://webrtc.github.io/samples/" target="_blank">WebRTC GitHub Samples</a></li>
        </ul>
    </div>


    <script>
      const startSharingButton = document.getElementById('startSharing');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const playVideoButton = document.getElementById('playVideoButton'); // Bot√≥n de reproducci√≥n manual
const signalingChannel = new BroadcastChannel('webrtc-signaling');

let peerConnection;
let isSharing = false; // Si esta pesta√±a est√° compartiendo
let iceCandidatesBuffer = []; // Buffer para ICE Candidates antes de setRemoteDescription()

async function startScreenSharing() {
    if (isSharing) return; // Evitar m√∫ltiples clics
    isSharing = true;

    try {
        const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        localVideo.srcObject = stream;

        // Cerrar la conexi√≥n anterior si existe y est√° activa
        if (peerConnection && peerConnection.signalingState !== "closed") {
            console.warn("‚ö†Ô∏è Ya existe una conexi√≥n activa. Ignorando nueva oferta.");
            return;
        }

        console.log("üîµ Creando nueva conexi√≥n WebRTC...");
        peerConnection = new RTCPeerConnection();

        // Enviar el stream de pantalla
        stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

        // Manejo de flujo entrante
        peerConnection.ontrack = (event) => {
            console.log("‚úÖ Stream recibido:", event.streams[0]);
            remoteVideo.srcObject = event.streams[0];

            // Intentar reproducir autom√°ticamente
            remoteVideo.play().catch(error => {
                console.warn("‚ö†Ô∏è No se pudo reproducir autom√°ticamente:", error);
                playVideoButton.style.display = "inline-block"; // Mostrar el bot√≥n si la reproducci√≥n falla
            });
        };

        // Manejo de ICE Candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log("üìå Enviando ICE Candidate...");
                signalingChannel.postMessage({ type: 'candidate', candidate: event.candidate.toJSON() });
            }
        };

        // Crear y enviar oferta SDP
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        signalingChannel.postMessage({ type: 'offer', offer });

    } catch (error) {
        console.error('‚ùå Error al compartir pantalla:', error);
        isSharing = false;
    }
}

// Agregar evento al bot√≥n "Reproducir Video"
playVideoButton.addEventListener("click", () => {
    if (remoteVideo.srcObject) {
        remoteVideo.play().then(() => {
            console.log("‚ñ∂ Video reproduci√©ndose correctamente.");
            playVideoButton.style.display = "none"; // Ocultar el bot√≥n despu√©s de hacer clic
        }).catch(error => {
            console.error("‚ùå No se pudo iniciar la reproducci√≥n manualmente:", error);
        });
    } else {
        console.warn("‚ö†Ô∏è No hay ning√∫n stream disponible para reproducir.");
    }
});

signalingChannel.onmessage = async (event) => {
    console.log("üì© Mensaje recibido:", event.data);

    if (event.data.type === 'offer') {
        if (peerConnection && peerConnection.signalingState !== "closed") {
            console.warn("‚ö†Ô∏è Ya existe una conexi√≥n activa. Ignorando nueva oferta.");
            return;
        }

        console.log("üîµ Creando nueva conexi√≥n WebRTC...");
        peerConnection = new RTCPeerConnection();

        peerConnection.ontrack = (event) => {
            console.log("‚úÖ Stream recibido:", event.streams[0]);
            remoteVideo.srcObject = event.streams[0];

            setTimeout(() => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    console.warn("‚ö†Ô∏è Volviendo a asignar el stream al remoteVideo...");
                    remoteVideo.srcObject = event.streams[0];
                }
                remoteVideo.play().catch(error => {
                    console.warn("‚ö†Ô∏è No se pudo reproducir autom√°ticamente:", error);
                    playVideoButton.style.display = "inline-block"; // Mostrar el bot√≥n si la reproducci√≥n falla
                });
            }, 500);
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log("üìå Enviando ICE Candidate...");
                signalingChannel.postMessage({ type: 'candidate', candidate: event.candidate.toJSON() });
            }
        };

        console.log("üîµ Aplicando setRemoteDescription(offer)");
        await peerConnection.setRemoteDescription(new RTCSessionDescription(event.data.offer));

        // Aplicar ICE Candidates almacenados en buffer
        while (iceCandidatesBuffer.length > 0) {
            let candidate = iceCandidatesBuffer.shift();
            console.log("‚úÖ Aplicando ICE Candidate del buffer:", candidate);
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        signalingChannel.postMessage({ type: 'answer', answer });

    } else if (event.data.type === 'answer') {
        console.log("üü¢ Aplicando setRemoteDescription(answer)");
        if (peerConnection.signalingState !== "stable") {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(event.data.answer));
        } else {
            console.warn("‚ö†Ô∏è La conexi√≥n ya est√° en estado 'stable', ignorando answer.");
        }

    } else if (event.data.type === 'candidate') {
        console.log("üìå Agregando ICE Candidate...");
        if (peerConnection.remoteDescription) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(event.data.candidate));
        } else {
            console.warn("‚ö†Ô∏è ICE Candidate recibido antes de setRemoteDescription(). Guardando en buffer.");
            iceCandidatesBuffer.push(event.data.candidate);
        }
    }
};

startSharingButton.addEventListener('click', startScreenSharing);
 

    </script>
</body>

</html>